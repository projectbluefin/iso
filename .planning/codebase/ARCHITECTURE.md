# Architecture

**Analysis Date:** 2026-01-28

## Pattern Overview

**Overall:** Build Pipeline Architecture with Declarative Configuration

**Key Characteristics:**
- GitHub Actions orchestration calling external ISO builder (Titanoboa)
- Declarative configuration through shell scripts and YAML workflows
- Clear separation between build orchestration and ISO generation
- Matrix-based parallel build strategy for multiple platform/flavor combinations

## Layers

**Workflow Orchestration Layer:**
- Purpose: Defines what ISOs to build and coordinates parallel builds
- Location: `.github/workflows/`
- Contains: Caller workflows and reusable workflow definitions
- Depends on: GitHub Actions runtime, Titanoboa ISO builder
- Used by: Manual triggers (workflow_dispatch), scheduled cron jobs, pull request events

**Build Matrix Configuration:**
- Purpose: Maps variant identifiers to specific platform/flavor combinations
- Location: `.github/workflows/reusable-build-iso-anaconda.yml` (determine-matrix job)
- Contains: JSON matrix definitions for each variant (stable, lts, lts-hwe, all)
- Depends on: Workflow inputs (image_version parameter)
- Used by: Build job step to generate parallel build matrix

**ISO Configuration Layer:**
- Purpose: Customizes the live environment and Anaconda installer behavior
- Location: `iso_files/`
- Contains: Shell scripts executed during ISO generation, configuration profiles
- Depends on: Base container image structure, Anaconda installer
- Used by: Titanoboa ISO builder during post-rootfs hook phase

**Build Automation Layer:**
- Purpose: Provides developer-facing commands for local builds and testing
- Location: `Justfile`, `just/`, `hack/`
- Contains: Just recipes for building, testing, and validating ISOs
- Depends on: Podman/Docker, Just command runner
- Used by: Developers for local development, CI validation steps

**Flatpak Management Layer:**
- Purpose: Defines which applications are pre-installed on ISOs
- Location: `flatpaks/` (deprecated in current workflow - now fetched from common repo)
- Contains: List files with flatpak application IDs
- Depends on: Flathub registry
- Used by: ISO build process to embed offline flatpak installations

## Data Flow

**Workflow Dispatch Build:**

1. User triggers workflow via GitHub Actions UI or API (selects variant: lts, lts-hwe, stable, all)
2. Caller workflow (e.g., `build-iso-stable.yml`) passes image_version to reusable workflow
3. Reusable workflow's determine-matrix job generates build matrix based on image_version
4. Matrix outputs JSON array of platform/flavor/image_version combinations
5. Build job spawns parallel runners for each matrix entry
6. Each runner:
   - Fetches flatpak list from projectbluefin/common repository
   - Constructs image reference using Just helper recipes
   - Invokes Titanoboa action with image-ref, hook script, and flatpak list
   - Titanoboa pulls container image, executes post-rootfs hook, generates ISO
7. Post-processing: Rename ISO with standardized name, generate SHA256 checksum
8. Conditional upload: GitHub artifacts if requested, CloudFlare R2 for non-PR builds

**Pull Request Build:**

1. PR modifies files in `iso_files/` or workflow configuration
2. Reusable workflow triggered directly with default matrix (stable only for fast validation)
3. Build job executes (same as step 6-7 above)
4. Artifacts uploaded to GitHub Actions for review

**Scheduled Build:**

1. Cron triggers caller workflow at 2am UTC on the 1st of month
2. Workflow calls reusable workflow with specific image_version
3. Default configuration: upload_r2 = true, upload_artifacts = false
4. Build and upload to CloudFlare R2 testing bucket

**State Management:**
- Stateless builds - each run starts fresh from base container image
- Build artifacts stored in runner workspace, cleaned after upload
- Container images pulled from `ghcr.io/ublue-os/bluefin*` registry
- ISO state managed by Titanoboa builder internally

## Key Abstractions

**Variant:**
- Purpose: Top-level identifier for ISO release streams (stable, lts, lts-hwe)
- Examples: `stable`, `lts`, `lts-hwe`, `all`
- Pattern: Passed as `image_version` input to reusable workflow

**Flavor:**
- Purpose: Specific feature variant within a release stream
- Examples: `main` (standard), `nvidia-open` (NVIDIA drivers), `gdx` (developer tools)
- Pattern: Combined with variant to determine final image name

**Platform:**
- Purpose: CPU architecture target
- Examples: `amd64` (x86_64), `arm64` (aarch64)
- Pattern: Determines runner type (`ubuntu-24.04` vs `ubuntu-24.04-arm`)

**Matrix Entry:**
- Purpose: Single unit of build work in parallel strategy
- Examples: `{"platform":"amd64","flavor":"main","image_version":"stable"}`
- Pattern: JSON object with three required keys, generated by determine-matrix job

**Hook Script:**
- Purpose: Post-rootfs customization during ISO generation
- Examples: `iso_files/configure_iso_anaconda.sh`, `iso_files/configure_lts_iso_anaconda.sh`
- Pattern: Shell script executed by Titanoboa after rootfs is constructed

**Image Reference:**
- Purpose: Fully qualified container image name
- Examples: `ghcr.io/ublue-os/bluefin:stable`, `ghcr.io/ublue-os/bluefin-dx:lts`
- Pattern: Constructed by Just recipe `image_name` based on variant/flavor

## Entry Points

**Caller Workflows:**
- Location: `.github/workflows/build-iso-{lts,lts-hwe,stable,all}.yml`
- Triggers: workflow_dispatch (manual), schedule (cron), workflow_call
- Responsibilities: Accept user inputs, call reusable workflow with specific image_version

**Reusable Build Workflow:**
- Location: `.github/workflows/reusable-build-iso-anaconda.yml`
- Triggers: workflow_call from caller workflows, pull_request on specific paths
- Responsibilities: Generate build matrix, orchestrate parallel ISO builds, handle uploads

**Just CLI Entry Point:**
- Location: `Justfile` (default recipe at line 29-31)
- Triggers: Developer running `just` command
- Responsibilities: List available recipes when invoked without arguments

**Local ISO Build Script:**
- Location: `hack/local-iso-build.sh`
- Triggers: Developer running `just local-iso` or directly executing script
- Responsibilities: Clone Titanoboa, configure build, execute local ISO generation

**ISO Configuration Scripts:**
- Location: `iso_files/configure_iso_anaconda.sh`, `iso_files/configure_lts_iso_anaconda.sh`
- Triggers: Titanoboa builder during post-rootfs phase
- Responsibilities: Configure live environment, install Anaconda, set up installer kickstart

## Error Handling

**Strategy:** Fail-fast with explicit error logging

**Patterns:**
- Workflow level: `fail-fast: false` in matrix strategy allows parallel builds to continue on individual failures
- Script level: `set -eoux pipefail` in shell scripts causes immediate exit on command failure
- Container pulls: `--retry-times 3` for network operations (skopeo, curl)
- Conditional execution: `continue-on-error: true` for non-critical steps (storage optimization)
- Upload gates: Conditional steps check `github.event_name` to prevent PR uploads to R2
- Validation: Pre-commit hooks enforce syntax checking before workflow execution

## Cross-Cutting Concerns

**Logging:** GitHub Actions automatic job/step logging with collapsible groups (`::group::`/`::endgroup::`)

**Validation:** 
- Pre-commit hooks for YAML/JSON/TOML syntax (`.pre-commit-config.yaml`)
- Just syntax checking (`just check` recipe)
- Flatpak ID validation against Flathub (deprecated - now fetched from common repo)

**Authentication:** 
- GitHub token automatically provided for container registry access
- CloudFlare R2 credentials passed as repository secrets
- Secrets inherited from caller to reusable workflow via `secrets: inherit`

**Resource Management:**
- Maximize build space by removing unwanted software (`ublue-os/remove-unwanted-software` action)
- Container storage on compressed BTRFS loop device (`container-storage-action`)
- Cleanup of intermediate build artifacts after ISO generation
- arm64 runners skip space optimization (already optimized)

**Permissions:**
- Managed centrally in reusable workflow (contents:read, packages:read, id-token:write)
- Caller workflows MUST NOT include permissions block (use `secrets: inherit` instead)
- Rootful container operations for ISO build (requires sudo/privileged mode)

---

*Architecture analysis: 2026-01-28*
